# 背包问题


## 01背包
背包问题的理论基础重中之重是01背包，一定要理解透！  
leetcode上没有纯01背包的问题，都是01背包应用方面的题目，也就是需要转化为01背包问题。  
如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。
### 二维dp数组01背包
dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。  
递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
```javascript
function testWeightBagProblem (weight, value, bagweight) {  //bagweight是背包的最大重量
    const len = weight.length;
    const dp = Array(len).fill().map(() => Array(bagweight + 1).fill(0));  //生成二维dp数组，初始化为0

    // 初始化
    for(let j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }

    // weight 数组的长度len 就是物品个数
    for(let i = 1; i < len; i++) { // 遍历物品
        for(let j = 0; j <= bagweight; j++) { // 遍历背包容量
            if(j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }
    console.table(dp);
    return dp[len - 1][bagweight];
}
function test () {
    console.log(testWeightBagProblem([1, 3, 4], [15, 20, 30], 4));
}
test();
```

### 一维dp数组（滚动数组）
如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])。与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。  
dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]  
此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的。所以递归公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i])。  
一维dp遍历的时候，背包是从大到小。每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。
```javascript
function testWeightBagProblem(weight, value, bagweight) {
  const len = weight.length;
  const dp = Array(bagweight + 1).fill(0);  //生成一维dp数组，初始化为0
  for(let i = 1; i <= len; i++) {    //for循环的顺序不可以修改
    for(let j = bagweight; j >= weight[i - 1]; j--) {    //倒序
      dp[j] = Math.max(dp[j], dp[j - weight[i - 1]]+value[i - 1]);
    }
  }
  return dp[bagweight];
}
function test () {
  console.log(testWeightBagProblem([1, 3, 4], [15, 20, 30], 4));
}
test();
```


## 完全背包











## 多重背包







## 分组背包